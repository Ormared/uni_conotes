2024-05-29 : 13:23

## З лекції 
![[Pasted image 20240529132342.png]]
![[Pasted image 20240529132351.png]]

#### Схема методу 
Вибираємо точність обчислень розв’язку x* - число $\epsilon>0$ 
**1-ий крок**. Обчислюємо
![[Pasted image 20240529132515.png]]

**2-ий крок.** Покладемо
![[Pasted image 20240529132537.png]]

![[Pasted image 20240529132546.png]]

![[Pasted image 20240529132609.png]]

Якщо умова виконується, процес розв’язування припиняється, і за
розв’язок х* вибираємо $х_k$. Якщо умова не виконується, продовжуємо поділ
## Від мене
```
def golden_section_search(f, a, b, tol=1e-6):

    golden_ratio = (1 + 5 ** 0.5) / 2

    # Початкові точки
    x1 = a + (1 - 1 / golden_ratio) * (b - a)
    x2 = a + (b - a) / golden_ratio

    # Обчислюємо значення функції в цих точках
    f1 = f(x1)
    f2 = f(x2)

    # Ітераційний процес
    while True:
        if abs(b - a) < tol:
            break

        if f1 < f2:
            b = x2
            x2 = x1
            x1 = a + (1 - 1 / golden_ratio) * (b - a)
            f2 = f1
            f1 = f(x1)
        else:
            a = x1
            x1 = x2
            x2 = a + (b - a) / golden_ratio
            f1 = f2
            f2 = f(x2)


    beta = (b + a) / 2
    return beta

```

## З Wiki

>1. На першій ітерації заданий відрізок ділиться двома симетричними відносно центру точками і розраховуються значення в цих точках.
2. Після чого той з кінців відрізка, до якого серед двох знову поставлених точок ближче виявилася та, значення в якій максимальне (для випадку пошуку мінімуму), відкидають.
3. На наступній ітерації в силу показаній вище властивості золотого перетину вже треба шукати лише одну нову точку.
4. Процедура триває, допоки не буде досягнута задана точність.